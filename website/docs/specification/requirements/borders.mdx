---
sidebar_position: 1
---

import { Diagram } from '@site/src/Diagram';

# Границы тестирования

Тест - это код верифицирующий программу на предмет соответствия некоторым признакам.

Начнём с того, что любой тестовый сценарий можно разделить на три основных этапа:

1. **Подготовка входных данных**: инициализация аргументов для тестируемой программы.
2. **Выполнение функций**: взаимодействие с программой для получения результатов её работы.
3. **Верификация**: проверка полученных результатов на соответствие установленным условиям.

Для повышения эффективности тестирования и достижения высоких показателей [метрик](/metrics) необходимо чётко определить
границы каждого из этих этапов.

## Определение границ

Спецификация выделяет следующие ключевые границы:

<Diagram src={require('./assets/test-arch.drawio.png')} />

:::note
Стрелки на диаграмме указывают направление потока информации.
:::

### Аргументы

Данные, необходимые для инициализации и передачи в функцию для получения результата. Состоят из двух компонентов:

- **Пользователь**: взаимодействие пользователя с приложением, включая клики и нажатия клавиш.
- **Внешняя среда**: данные и события, получаемые из внешних источников, такие как текущая дата или информация из
  локальных хранилищ.

Спецификация описывает методы их *инициализации*.

### Результат

Данные, которые необходимо проверить для обеспечения защиты от регресса. Включают:

- **Монитор**: отображаемый пользовательский интерфейс. Стратегия проверки - сопоставления изображений.
- **Хранилище**: изменения в данных внешних источников, например, обновления в базе данных. Стратегия проверки -
  сопоставление журналов вызовов.

Спецификация описывает способы их *верификации*.

### Функция

Компонент, преобразующий аргументы в результат. Представлен блоком AUT (сокр. application under test, то есть
тестируемое приложение) и является основным объектом тестирования. Чем крупнее этот блок, тем выше защита от регресса.

:::tip
Блок AUT можно рассматривать и более тривиальным образом, представьте что ваше веб-приложение это обычная функция, тогда
её аргументом станут пользовательские события взаимодействия, а результатом - изображение на экране.
:::

:::note Нулевая сумма
Секции связаны между собой, так как формируют единую программу, таким образом, увеличение объёма одной, приведёт к
уменьшению размера всех оставшихся секций.
:::

Для повышения защиты от регресса рекомендуется включать как можно больше функциональности в тестируемый блок AUT. Это
достигается за счёт упрощения и минимизации оставшихся секций, а именно аргументов и результата.

### Связь с библиотекой

`storyshots` объединяет данные концепции в одну единую сущность - историю:

- **Аргументы** истории описываются в функциях `act` и `arrange`.
- **AUT** в истории принимает функция `render` отвечающая за отображение UI на экране.
- **Результат** истории это отображаемое приложение и её внешние сайд-эффекты.

## Схема работы

Общая схема выглядит следующим образом:

<Diagram src={require('./assets/testing.drawio.png')} />

Разберём компоненты по порядку:

* **AUT** — это одноимённый компонент [функция](/specification/requirements/borders#функция). Всё, что делает наше
  приложение, за исключением элементов из секции аргументов и результата.
* **Слепок** — это артефакт поведения приложения, представленный в виде значения. Слепок
  включает [изображения](/specification/requirements/monitor)
  и [журналы вызовов](/specification/requirements/storage).
* **Эталон** — это хранилище, содержащее слепок поведения приложения. Каждый элемент закреплён за определённым тестом
  для последующего сравнения.

При первом запуске функция генерирует своё текущее поведение в виде слепка, который сохраняется в эталон как целевой.
При последующих запусках слепки сравниваются, что позволяет фиксировать факт изменения поведения приложения.

:::tip
Эталон является *baseline* компонентом в технике
тестирования [golden master](https://blog.thecodewhisperer.com/permalink/surviving-legacy-code-with-golden-master-and-sampling).
:::

:::warning Важно
Эталон не всегда отражает корректное поведение программы. Это лишь слепок, который может использоваться для анализа
изменений, например, при рефакторинге.
:::
