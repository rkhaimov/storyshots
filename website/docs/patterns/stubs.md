---
sidebar_position: 5
---

import { MetricsTip, Metric } from '@site/src/MetricsTip';

# Написание заглушек

`storyshots` благодаря своей архитектуре сводит к минимуму действия требуемые при написании тестовых сценариев, однако,
остаётся одна область которая будет требовать существенного внимания от разработчика, а именно - заглушки.

:::note
Заглушки занимают наибольший суммарный объём кода в тестах написанных с использованием `storyshots`.
:::

## Модульные заглушки

<MetricsTip improves={[Metric.Maintainability, Metric.Speed]} degrades={[Metric.RefactoringAllowance]} />

Одним из вариантов их упрощения является использование модульной структуры схожей с [модульной внешней средой](/patterns/externals#модульные-externals). Если
расширяемой единицей в случае репозиториев был метод, то в случае с заглушками это будут её свойства:

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
function createUserStub(): User {
    return {
        name: 'Vasiliy',
        position: 'developer',
        living: {
            city: 'Moscow',
        },
        /* И ещё 20+ свойств */
    };
}
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
/**
 * Описать минимальный набор полей для всех историй или оставить пустым
 */
function createMinimalUserStub(): User {
    return {
        name: 'Vasiliy',
        position: 'developer',
    } as User;
}

it('displays living address', {
    arrange: (user) => ({
        getUser: async () => ({
            ...createMinimalUserStub(),
            living: { city: 'Moscow' } // История устанавливает только нужные ей поля 
        })
    })
});
```

Модульность позволяет историям определять только нужные им данные в заглушках, но это лишь один из инструментов
сокращения их объёма. Другие варианты также приведены в данном руководстве.

:::note
Заглушки также наследуют от репозиториев проблемы связанные с отвественностью, которые были описаны подробно в
разделе [модульная внешняя среда](/patterns/externals#модульные-externals).
:::

:::warning Важно
Следует применять с осторожностью решения для генерации заглушек на
подобии [faker-js](https://github.com/faker-js/faker). Так как подобные решения зачастую используют рандомные числа в
своих механизмах делая их [недереминированными](/specification/requirements/env#идемпотентность).
:::

## Неизбыточные заглушки

<MetricsTip improves={[Metric.Maintainability, Metric.Speed]} />

Следует определять только те методы, что на самом деле используются приложением.

:::note
Данный пункт имеет тесную связь с [модульными заглушками](/patterns/stubs#модульные-заглушки). Однако, если последний описывал конкретный способ
разделения и последующей композиции, то данный раздел направлен на более абстрактное представление проблемы.
:::

Довольно частым виновником больших по объёму стабов является не само поведение, а типы описанные в исходном коде:

```ts
// Все поля в модели обязательные и при этом их достаточно много
type User = {
    name: string,
    position: string,
    living: {
        city: string,
    },
    /* И ещё 20+ свойств */
}
```

:::note
Компилятор требует от разработчика объявить все обязательные поля описанные в модели, даже при написании заглушки для
теста.
:::

Проблема заключается в том, что данные типы просто копируются из сторонних систем, например `swagger` и в конечном итоге
не отражают реального положения вещей: приложение может использовать только 5 полей из 20, в то время как в заглушках
объявляются все свойства без исключений.

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
type User = {
    name: string,
    position: string,
    living: {
        city: string,
    },
}
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
/**
 * Делать модель более точной и избавляться от неиспользуемых полей
 */
type User = {
    name: string,
    position?: string,
}
```

:::warning Важно
На проектах зачастую используются разного рода генераторы интерфейсов API. Это удобный инструмент и позволяет избавиться
от проблем связанных с дублированием на проекте, однако точность результата генерации зачастую оставляет желать лучшего.
Следует внимательней относиться к заглушкам в особенности если используются такие средства на проекте.
:::

## Релевантные заглушки

<MetricsTip improves={[Metric.RegressionProtection, Metric.Maintainability]} />

Тестовые данные (или другими словами стабы), являются критически важным элементом тестового сценария. Важно, чтобы
содержание заглушек соответствовало доменным требованиям и условиям диктуемым моделью:

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
function createUserStub(): User {
    return {
        name: 'UserName',
        roles: [],
    };
}
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
function createUserStub(): User {
    return {
        name: 'Васильев Василий Васильевич', // Имя пользователя содержит ФИО
        roles: ['admin'], // Роли по модели не могут быть пустыми
    };
}
```

Релевантные по отношению к предметной области и модели заглушки приносят следующие преимущества в тесты:

* Защита от регресса - заглушки обладают ровно теми свойствами, что и реальные данные на сервере. Это увеличивает
  эффективность тестирования, ведь система верифицируется в идентичном реальному окружении.
* Документация - за счёт использования более репрезентативных данных сами истории и снимки в эталоне больше
  напоминают реальное приложение и могут использоваться в качестве дополнительного источника документации.

:::note
Определение нерелевантных заглушек можно сравнить с тем что мы заставляем наше приложение общаться со "сломанным"
сервером, что очевидно негативно повлияет на стабильность самих историй и увеличит их хрупкость.
:::

## Достаточные заглушки

<MetricsTip improves={[Metric.Speed, Metric.Maintainability]} />

Данные должны быть настолько разнообразными, насколько того требует покрытия основного и всех альтернативных сценариев
работы приложения. С другой стороны, они должны сохранить свою не избыточность - соблюдаемую только тогда, когда из них
нельзя убрать ничего и не потерять при этом в их достаточности.

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
function createUserStub(): User {
    return {
        name: 'Vasiliy',
        address: 'Moscow'
    };
}
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
function createUserStub(): User {
    return {
        name: 'Vasiliy',
        /**
         * Поле с адресом убрано так как оно не используется в приложении
         * и как следствие не требуется для покрытия всех его сценариев.
         */
    };
}
```

:::tip
Данный паттерн тесно связан с [модульными заглушками](/patterns/stubs#модульные-заглушки).
:::

## Упрощённые заглушки

<MetricsTip improves={[Metric.Maintainability]} />

Тестовые данные содержат в себе множество комплексных полей, такие как: идентификаторы, ссылки на другие сущности, даты.
Следует устанавливать как можно более простые значения для таких свойств.

:::tip
Это снижает сложность самих заглушек и при этом никак не влияет на покрытие тестов.
:::

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
function createUserStub(): User {
    return {
        id: 5142,
        name: 'Vasiliy',
        updatedAt: '2024-06-28T15:00:00.000Z',
    };
}
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
function createUserStub(): User {
    return {
        id: 1,
        name: 'Vasiliy',
        updatedAt: createConstDate().toJSON(),
    };
}

/**
 * Установить любую фиксированную дату, актуальную для всех историй. По необходимости её можно смещать в конкретных фабриках.
 */
declare function createConstDate(): Date;
```
