---
sidebar_position: 6
---

import { MetricsTip, Metric } from '@site/src/MetricsTip';

# Внешняя среда

[Внешняя среда](/specification/requirements/env) - это один из ключевых компонентов `storyshots`, работа с которым бывает не простой и требует особого
внимания для сохранения качества тестирования.

## Игнорирование query

<MetricsTip improves={[Metric.RefactoringAllowance, Metric.Maintainability]} degrades={[Metric.RegressionProtection]} />

`storyshots` предоставляет методы для отслеживания вызовов функций, а именно [журнал](/specification/requirements/storage#способ-верификации). Записывать можно абсолютно
любой метод и тут зачастую возникает путаница. Рассмотрим пример:

```ts
const createMockUserRepository = (): UserRepository => {
    return {
        getUser: async () => createUserStub(),
    }
}
```

`UserRepository` содержит метод `getUser` который не выполняет никаких сайд-эффектов в БД, но является не
детерминированным. Вследствие этого он относится к компоненту [внешней среды](/specification/requirements/env), что означает что взаимодействия с
данной функцией не должны отслеживаться ведь она не является частью секции *результата*.

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
it('shows user', {
    arrange: (externals, { journal }) => ({
        ...externals,
        getUser: journal.asRecordable('getUser', externals.getUser)
    }),
})
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
// Не маркировать метод getUser
it('shows user');
```

Отслеживание `getUser` является бессмысленным так как метод не выполняет сайд-эффект.

:::tip
[Cайд-эффект](/specification/requirements/storage#сайд-эффект) - это не просто результат работы выходящий за пределы функции, в рамках спецификации это ещё и
*видимые* сторонними клиентами данные:

* Для сервера - это команды модифицирующие БД
* Для пользователя - это функции рисующие интерфейс на экране

Такие внешние эффекты и фиксируются `storyshots` в эталоне.
:::

Взаимодействие с `getUser` проверяется транзитивно, через отображение компонента в котором используются данные из
метода:

```tsx
const User: React.FC = () => {
    const response = useQuery(userRepository.getUser);

    if (response.loading) {
        return <Preloader />;
    }

    return <UserInfo user={response.data} />
};
```

:::warning Важно
У данного правила есть одно очень важное исключение - запросы, такие как `getUser`, хоть и не выполняют сайд-эффектов,
однако могут реализовывать не тривиальную логику, опирающуюся на то, с какими *аргументами* был вызван метод.

Рекомендуется фиксировать в журнал взаимодействия с подобного рода запросами.
:::

## Нестабильные представления

<MetricsTip improves={[Metric.RegressionProtection]} degrades={[Metric.Maintainability, Metric.Speed]} />

К сожалению, далеко не всегда существует возможность полного контроля над [внешней средой](/specification/requirements/env) приложения. Вследствие
чего появляется вероятность получения нестабильного эталона.

:::tip
Примером может служить компонент сторонней библиотеки - нотификация, итоговая позиция которой при появлении не всегда
одинаковая и из-за этого страдают снимки экрана.
:::

В данного рода проблемой поможет справиться функция `retries`:

```ts
it('shows read notification', {
    // У теста будет три попытки на успешное прохождение
    retries: (config) => 3,
});
```

:::warning Внимание
Данный метод не рекомендуется использовать в общем случае. Следует либо [подменить](/patterns/replace) функцию виновника, либо целую
библиотеку. Также можно исключить сам тестовый сценарий.
:::

## Таймеры

<MetricsTip improves={[Metric.Maintainability, Metric.Speed]} />

UI интерфейсы полны асинхронных взаимодействий, частью которых являются таймеры.

Рассмотрим следующий пример:

```ts
// Показать уведомление
const notification = showMessage('Сообщение прочитано');

// Закрыть через 5 секунд
setTimeout(() => notification.close(), 5_000);
```

Функция выше, показывает пользователю уведомление, после чего ожидает 5 секунд и закрывает его. При тестировании данного
поведения, необходимо помнить о запрете использования [оригинального внешнего окружения](/specification/requirements/env) в историях.

<p style={{ color: 'red' }}>Вместо этого:</p>

```ts
it('shows message to a user', {
    act: (actor) => actor
        .screenshot('Message')
        .wait(5_000)
        .screenshot('Hidden'),
}); 
```

<p style={{ color: 'green' }}>Делать это:</p>

```ts
it('shows message to a user', {
    act: (actor) => actor
        .screenshot('Message')
        // Отправить таймеры в будущее на 5 секунд вперёд
        .exec(() => window.tick(5_000))
        .screenshot('Hidden'),
});
```

Функция `wait` из примера будет ожидать 5 секунд после чего продолжит выполнение теста. Это непозволительно, так как
время выполнения теста - это крайне важная величина. Поэтому во втором примере используются ложные таймеры.

:::note
В данном примере используется библиотека [`@storyshots/web-api-externals`](/modules/web-api) которая
выполняет [подмену через сайд-эффекты](/patterns/replace#подмена-через-сайд-эффекты).
:::

:::warning Внимание
Существует также альтернатива ввиде подмены API через [инверсию зависимостей](/patterns/replace#подмена-через-инверсию), однако данный метод не является
рекомендуемым.
:::
